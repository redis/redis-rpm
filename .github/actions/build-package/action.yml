name: "Build RPM package"
description: "Builds Redis RPM package for specified distribution and architecture"

inputs:
  distro:
    description: "Distribution name (e.g., rockylinux)"
    required: true
  distro_version:
    description: "Distribution version (e.g., 8, 9)"
    required: true
  platform:
    description: "Platform/architecture (e.g., amd64, arm64)"
    required: true
  release_tag:
    description: "Release tag (version or 'unstable')"
    required: true

runs:
  using: "composite"
  steps:
    - name: Log in to GitHub Container Registry
      shell: bash
      run: |
        echo "${{ github.token }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

    # Spin up a container directly since we neither can use "container" option
    # on job level (because it doesn't support external actions with file
    # dependencies as "Ensure release branch") nor we have ready to use
    # containerized action
    # As a bonus side effect we use docker-builder wrapper shell to capture the
    # output from exec commands into LOG_FILENAME
    - name: Start builder container
      shell: bash
      run: |
        docker run -d --name builder \
          -v "$PWD:/workspace" \
          -w /workspace \
          ghcr.io/${{ github.repository }}/builder:${{ inputs.distro }}${{ inputs.distro_version }} \
          bash -c 'touch ./.started && sleep infinity'
          echo "Waiting for container to start..."
          timeout -v 5 bash -c 'while [ ! -f ./.started ]; do sleep 0.1; done'

    - name: Create docker-builder wrapper
      shell: bash
      run: |
        LOG_FILENAME="build-failure-${{ inputs.platform }}-${{ inputs.distro }}${{ inputs.distro_version }}.log"
        echo LOG_FILENAME=$LOG_FILENAME >> $GITHUB_ENV
        mkdir -p logs

        dir=$(mktemp -d)
        cat > /$dir/docker-builder <<EOF
        #!/bin/bash
        cat "\$1" | docker exec -i builder bash 2>&1 | tee "logs/$LOG_FILENAME"
        EOF
        chmod 0755 $dir/docker-builder
        echo "$dir" >> $GITHUB_PATH
        echo "docker-builder wrapper created in $dir:"
        cat $dir/docker-builder

    - name: Determine version
      id: version
      shell: bash
      run: |
        if [ "${{ inputs.release_tag }}" = "unstable" ]; then
          VERSION="unstable"
        else
          if [ -f ".redis_version" ]; then
            VERSION=$(cat .redis_version)
          else
            echo "Error: .redis_version file not found and release_tag is not 'unstable'"
            exit 1
          fi
        fi
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "Building version: $VERSION"

    - name: Build Redis with modules in container
      id: build_redis
      shell: docker-builder {0}
      run: |
        set -e
        # Source gcc-toolset-13 environment
        source /etc/profile.d/gcc-toolset-13.sh
        export BUILD_WITH_MODULES=yes
        export INSTALL_RUST_TOOLCHAIN=yes
        export DISABLE_WERRORS=yes
        export BUILD_TLS=yes
        export USE_SYSTEMD=yes

        makeerror

        if [ "${{ steps.version.outputs.VERSION }}" = "unstable" ]; then
          # Clone Redis unstable branch instead of downloading release tarball
          git clone --depth 1 https://github.com/redis/redis.git -b unstable
          cd redis

          # Update module versions to use master branch
          echo "Updating module versions to use master branch..."
          for module in redisbloom redisearch redistimeseries redisjson; do
            if [ -f "modules/${module}/Makefile" ]; then
              echo "Updating ${module} to use master branch"
              sed -i "s/MODULE_VERSION = .*/MODULE_VERSION = master/" "modules/${module}/Makefile"
              cat "modules/${module}/Makefile" | grep "MODULE_VERSION"
            fi
          done
        else
          # Download and extract Redis source
          curl -L "https://github.com/redis/redis/archive/refs/tags/${{ steps.version.outputs.VERSION }}.tar.gz" -o redis.tar.gz
          tar xzf redis.tar.gz
          cd redis-${{ steps.version.outputs.VERSION }}
        fi

        # Build Redis
        make -j "$(nproc)" all
        make install PREFIX=/usr/local
        echo "Contents of /usr/local/lib/redis/modules/:"
        ls -la /usr/local/lib/redis/modules/

    - name: Install Go and nfpm in container
      shell: docker-builder {0}
      run: |
        set -e

        # Install Go and nfpm
        export GOPATH=/tmp/go
        export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin

        # Check if Go is installed, if not install it
        if ! command -v go &> /dev/null; then
          echo "Installing Go..."
          curl -L https://go.dev/dl/go1.21.0.linux-${{ inputs.platform == 'amd64' && 'amd64' || 'arm64' }}.tar.gz -o go.tar.gz
          tar -C /usr/local -xzf go.tar.gz
          rm go.tar.gz
        fi

        # Install nfpm
        go install github.com/goreleaser/nfpm/v2/cmd/nfpm@latest

    - name: Build RPM package
      shell: docker-builder {0}
      run: |
        set -e

        # Set up environment
        export GOPATH=/tmp/go
        export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin

        # Build RPM package
        cp templates/nfpm.yaml.tpl nfpm.yaml
        mkdir -p dist
        VERSION=${{ steps.version.outputs.VERSION }} ARCH=${{ inputs.platform }} nfpm package --packager rpm --target dist

    - name: Upload logs when failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: build-failure-${{ inputs.platform }}-${{ inputs.distro }}${{ inputs.distro_version }}
        path: logs/${{ env.LOG_FILENAME }}
        retention-days: 7

    - name: Stop builder container
      shell: bash
      if: always()
      run: |
        docker stop builder || true
        docker rm builder || true

    - name: Upload RPM artifact
      uses: actions/upload-artifact@v4
      with:
        name: rpm-${{ inputs.distro }}${{ inputs.distro_version }}-${{ inputs.platform }}
        path: dist/*.rpm

    - name: Cleanup
      shell: bash
      if: always()
      run: |
        rm -rf redis redis-*.tar.gz